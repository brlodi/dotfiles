#!/usr/bin/env bash
# Design and presentational code by Benjamin Lodi (@brlodi),
# logic and git status detection adapted from `sexy bash prompt` by twolfson
# https://github.com/twolfson/sexy-bash-prompt
# Forked from gf3, https://gist.github.com/gf3/306785


# Sexy Bash Prompt uses 256 colors for this, but I'd rather have it pull from my base16
# color scheme instead. Make sure the terminal emulator has "draw bold text in bright
# colors" turned off or it will look approximately like ass
sbp_user_color=4 # BLUE
sbp_device_color=6 # CYAN
sbp_dir_color=2 # GREEN
sbp_git_status_color=3 # YELLOW
sbp_git_progress_color=1 # RED
sbp_neutral_dark=11 # "BRIGHT YELLOW" (actually a dark grey-ish in base16 color schemes)
					# WARNING: this gets overridden for ANSI below, CHANGE IT THERE TOO!
sbp_neutral_light=7 # WHITE

# The glyph to use for connecting prompt segments
sbp_connector=""

# If we are on a colored terminal
if tput setaf 1 &> /dev/null; then
  # Reset the shell from our `if` check
  tput sgr0 &> /dev/null

  # If you would like to customize your colors, use
  # # Attribution: http://linuxtidbits.wordpress.com/2008/08/11/output-color-on-bash-scripts/
  # for i in $(seq 0 $(tput colors)); do
  #   echo " $(tput setaf $i)Text$(tput sgr0) $(tput bold)$(tput setaf $i)Text$(tput sgr0) $(tput sgr 0 1)$(tput setaf $i)Text$(tput sgr0)  \$(tput setaf $i)"
  # done

  # Save common color actions
  sbp_bold="$(tput bold)"
  sbp_reset="$(tput sgr0)"
  sbp_default_bg="$(tput setab 256)"
  sbp_invert="$(tput setaf 256)" # "Transparent" text, shows terminal background color

  # These are the colors for the main text boxes of the prompt, not including the arrows
  sbp_user_bg="$(tput setab $sbp_user_color)"
  sbp_device_bg="$(tput setab $sbp_device_color)"
  sbp_dir_bg="$(tput setab $sbp_dir_color)"
  sbp_git_bg="$(tput setab $sbp_neutral_dark)"
  sbp_user_fg="$sbp_invert"
  sbp_device_fg="$sbp_invert"
  sbp_dir_fg="$sbp_invert"
  sbp_git_status_fg="$(tput setaf $sbp_git_status_color)"
  sbp_git_progress_fg="$(tput setaf $sbp_git_progress_color)"
  sbp_symbol_fg="$sbp_neutral_light"
  sbp_user_cn="$(tput setaf $sbp_user_color)"
  sbp_device_cn="$(tput setaf $sbp_device_color)"
  sbp_dir_cn="$(tput setaf $sbp_dir_color)"
  sbp_git_cn="$(tput setaf $sbp_neutral_dark)"

else
  # Otherwise, use ANSI escape sequences for coloring
  # If you would like to customize your colors, use
  # DEV: 30-39 lines up 0-9 from `tput`
  # for i in $(seq 0 109); do
  #   echo -n -e "\033[1;${i}mText$(tput sgr0) "
  #   echo "\033[1;${i}m"
  # done

  sbp_bold="\033[1m"
  sbp_reset="\033[m"
  sbp_default_bg="\033[49m"
  sbp_invert="\033[$(expr 30 + 0)m" # Have to settle for black fg, there's no "transparent"

  sbp_user_bg="\033[$(expr 40 + $sbp_user_color)m"
  sbp_device_bg="\033[$(expr 40 + $sbp_device_color)m"
  sbp_dir_bg="\033[$(expr 40 + $sbp_dir_color)m"
  # WARNING: this is manually overridden. If you change $sbp_neutral_dark above, change this too
  sbp_git_bg="\033[40m" # Best we can do is a black BG color
  sbp_user_fg="$sbp_invert"
  sbp_device_fg="$sbp_invert"
  sbp_dir_fg="$sbp_invert"
  sbp_git_status_fg="\033[$(expr 30 + $sbp_git_status_color)m"
  sbp_git_progress_fg="\033[$(expr 30 + $sbp_git_progress_color)m"
  sbp_symbol_fg="\033[$(expr 30 + $sbp_neutral_light)m"
  sbp_user_cn="\033[$(expr 30 + $sbp_user_color)m"
  sbp_device_cn="\033[$(expr 30 + $sbp_device_color)m"
  sbp_dir_cn="\033[$(expr 30 + $sbp_dir_color)m"
  # WARNING: this is manually overridden. If you change $sbp_neutral_dark above, change this too
  sbp_git_cn="\033[30m"

fi

# Define the actual prompt styles
sbp_start_cap="$sbp_invert"
sbp_user_bar="$sbp_user_bg$sbp_connector$sbp_user_fg \u $sbp_user_cn"
sbp_device_bar="$sbp_device_bg$sbp_connector$sbp_device_fg \h $sbp_device_cn"
sbp_dir_bar="$sbp_dir_bg$sbp_connector$sbp_dir_fg \w $sbp_dir_cn"
sbp_git_bar="$sbp_git_bg$sbp_connector$sbp_git_status_fg \$(sbp_get_git_info)$sbp_git_progress_fg\$(sbp_get_git_progress) $sbp_git_cn"
sbp_end_cap="$sbp_default_bg$sbp_connector$sbp_reset"

# Define the default prompt terminator character '$'
if [[ "$UID" == 0 ]]; then
  sbp_symbol="#"
else
  sbp_symbol="\$"
fi

# Set up symbols
sbp_synced_symbol=""
sbp_dirty_synced_symbol="*"
sbp_unpushed_symbol="△"
sbp_dirty_unpushed_symbol="▲"
sbp_unpulled_symbol="▽"
sbp_dirty_unpulled_symbol="▼"
sbp_unpushed_unpulled_symbol="⬡"
sbp_dirty_unpushed_unpulled_symbol="⬢"

function sbp_get_git_branch() {
  # On branches, this will return the branch name
  # On non-branches, (no branch)
  ref="$(git symbolic-ref HEAD 2> /dev/null | sed -e 's/refs\/heads\///')"
  if [[ "$ref" != "" ]]; then
    echo "$ref"
  else
    echo "(no branch)"
  fi
}

function sbp_get_git_progress() {
  # Detect in-progress actions (e.g. merge, rebase)
  # https://github.com/git/git/blob/v1.9-rc2/wt-status.c#L1199-L1241
  git_dir="$(git rev-parse --git-dir)"

  # git merge
  if [[ -f "$git_dir/MERGE_HEAD" ]]; then
    echo " [merge]"
  elif [[ -d "$git_dir/rebase-apply" ]]; then
    # git am
    if [[ -f "$git_dir/rebase-apply/applying" ]]; then
      echo " [am]"
    # git rebase
    else
      echo " [rebase]"
    fi
  elif [[ -d "$git_dir/rebase-merge" ]]; then
    # git rebase --interactive/--merge
    echo " [rebase]"
  elif [[ -f "$git_dir/CHERRY_PICK_HEAD" ]]; then
    # git cherry-pick
    echo " [cherry-pick]"
  fi
  if [[ -f "$git_dir/BISECT_LOG" ]]; then
    # git bisect
    echo " [bisect]"
  fi
  if [[ -f "$git_dir/REVERT_HEAD" ]]; then
    # git revert --no-commit
    echo " [revert]"
  fi
}

sbp_is_branch1_behind_branch2 () {
  # $ git log origin/master..master -1
  # commit 4a633f715caf26f6e9495198f89bba20f3402a32
  # Author: Todd Wolfson <todd@twolfson.com>
  # Date:   Sun Jul 7 22:12:17 2013 -0700
  #
  #     Unsynced commit

  # Find the first log (if any) that is in branch1 but not branch2
  first_log="$(git log $1..$2 -1 2> /dev/null)"

  # Exit with 0 if there is a first log, 1 if there is not
  [[ -n "$first_log" ]]
}

sbp_branch_exists () {
  # List remote branches           | # Find our branch and exit with 0 or 1 if found/not found
  git branch --remote 2> /dev/null | grep --quiet "$1"
}

sbp_parse_git_ahead () {
  # Grab the local and remote branch
  branch="$(sbp_get_git_branch)"
  remote_branch="origin/$branch"

  # $ git log origin/master..master
  # commit 4a633f715caf26f6e9495198f89bba20f3402a32
  # Author: Todd Wolfson <todd@twolfson.com>
  # Date:   Sun Jul 7 22:12:17 2013 -0700
  #
  #     Unsynced commit

  # If the remote branch is behind the local branch
  # or it has not been merged into origin (remote branch doesn't exist)
  if (sbp_is_branch1_behind_branch2 "$remote_branch" "$branch" ||
      ! sbp_branch_exists "$remote_branch"); then
    # echo our character
    echo 1
  fi
}

sbp_parse_git_behind () {
  # Grab the branch
  branch="$(sbp_get_git_branch)"
  remote_branch="origin/$branch"

  # $ git log master..origin/master
  # commit 4a633f715caf26f6e9495198f89bba20f3402a32
  # Author: Todd Wolfson <todd@twolfson.com>
  # Date:   Sun Jul 7 22:12:17 2013 -0700
  #
  #     Unsynced commit

  # If the local branch is behind the remote branch
  if sbp_is_branch1_behind_branch2 "$branch" "$remote_branch"; then
    # echo our character
    echo 1
  fi
}

function sbp_parse_git_dirty() {
  # If the git status has *any* changes (e.g. dirty), echo our character
  if [[ -n "$(git status --porcelain 2> /dev/null)" ]]; then
    echo 1
  fi
}

function sbp_is_on_git() {
  git rev-parse 2> /dev/null
}

function sbp_get_git_status() {
  # Grab the git dirty and git behind
  dirty_branch="$(sbp_parse_git_dirty)"
  branch_ahead="$(sbp_parse_git_ahead)"
  branch_behind="$(sbp_parse_git_behind)"

  # Iterate through all the cases and if it matches, then echo
  if [[ "$dirty_branch" == 1 && "$branch_ahead" == 1 && "$branch_behind" == 1 ]]; then
    echo "$sbp_dirty_unpushed_unpulled_symbol"
  elif [[ "$branch_ahead" == 1 && "$branch_behind" == 1 ]]; then
    echo "$sbp_unpushed_unpulled_symbol"
  elif [[ "$dirty_branch" == 1 && "$branch_ahead" == 1 ]]; then
    echo "$sbp_dirty_unpushed_symbol"
  elif [[ "$branch_ahead" == 1 ]]; then
    echo "$sbp_unpushed_symbol"
  elif [[ "$dirty_branch" == 1 && "$branch_behind" == 1 ]]; then
    echo "$sbp_dirty_unpulled_symbol"
  elif [[ "$branch_behind" == 1 ]]; then
    echo "$sbp_unpulled_symbol"
  elif [[ "$dirty_branch" == 1 ]]; then
    echo "$sbp_dirty_synced_symbol"
  else # clean
    echo "$sbp_synced_symbol"
  fi
}

sbp_get_git_info () {
  # Grab the branch
  branch="$(sbp_get_git_branch)"

  # If there are any branches
  if [[ "$branch" != "" ]]; then
    # Echo the branch
    output="$branch"

    # Add on the git status
    output="$output$(sbp_get_git_status)"

    # Echo our output
    echo "$output"
  fi
}

# Define the sexy-bash-prompt
PS1="\[$sbp_start_cap\]\[$sbp_bold\]\
\[$sbp_user_bar\]\
\[$sbp_device_bar\]\
\[$sbp_dir_bar\]\
\$( sbp_is_on_git && echo -n \"\[$sbp_git_bar\]\" )\
\[$sbp_end_cap\]\
\n\[$sbp_symbol_color\]\[$sbp_bold\]$sbp_symbol \[$sbp_reset\]"
